package main

import (
	"flag"
	"fmt"
	"mime"
	"strconv"
	"strings"

	"github.com/bluekaki/pkg/vv/pkg/plugin/protoc-gen-message-validator/options"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/pluginpb"
)

const version = "1.1.5"

func main() {
	showVersion := flag.Bool("version", false, "print the version and exit")
	flag.Parse()
	if *showVersion {
		fmt.Printf("protoc-gen-message-validator %v\n", version)
		return
	}

	protogen.Options{}.Run(func(gen *protogen.Plugin) error {
		gen.SupportedFeatures = uint64(pluginpb.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL)
		for _, f := range gen.Files {
			if !f.Generate {
				continue
			}
			generateFile(gen, f)
		}
		return nil
	})
}

// generateFile generates a _grpc.pb.go file containing gRPC service definitions.
func generateFile(gen *protogen.Plugin, file *protogen.File) {
	filename := file.GeneratedFilenamePrefix + "_message.pb.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)

	g.P("// Code generated by protoc-gen-message-validator. DO NOT EDIT.")
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()

	for _, message := range file.Messages {
		structName := string(message.Desc.Name())
		prefix := strings.ToLower(string(structName[0]))

		for _, subMessage := range message.Messages {
			if subMessage.Desc.IsMapEntry() {
				continue
			}

			subStructName := string(subMessage.Desc.Name())
			generateMessage(fmt.Sprintf("%s_%s", structName, subStructName), prefix, subMessage, g)
		}

		generateMessage(structName, prefix, message, g)
	}
}

func generateMessage(structName, prefix string, message *protogen.Message, g *protogen.GeneratedFile) {
	if mediaValidator, _ := proto.GetExtension(message.Desc.Options(), options.E_Media).(*options.MediaValidator); mediaValidator != nil {
		if mediaValidator.ContentType != nil && *mediaValidator.ContentType != "" {
			contentType, _, err := mime.ParseMediaType(*mediaValidator.ContentType)
			if err != nil {
				panic(err)
			}

			g.P("func (", prefix, "*", structName, ") ContentType() string {")
			g.P("return ", `"`, contentType, `"`)
			g.P("}")

			g.P("func (", prefix, "*", structName, ") Payload() []byte {")
			g.P("return ", prefix, ".Raw")
			g.P("}")
		}
	}

	g.P("func (", prefix, "*", structName, ") Validate() error {")

	for _, field := range message.Fields {
		desc := field.Desc

		g.P()
		g.P("// ", field.GoName, " ",
			" Kind:", desc.Kind().GoString(),
			" Cardinality:", desc.Cardinality(),
			" IsList:", desc.IsList(),
			" IsMap:", desc.IsMap(),
			" IsPacked:", desc.IsPacked(),
			" IsPlaceholder:", desc.IsPlaceholder(),
			" IsWeak:", desc.IsWeak(),
			" IsExtension:", desc.IsExtension(),
			" HasPresence:", desc.HasPresence(),
		)

		if desc.Kind() == protoreflect.StringKind {
			if desc.IsList() {
				g.P("for i := range ", prefix, ".", field.GoName, "{")
				g.P(prefix, ".", field.GoName, "[i] = ", stringsPackage.Ident("TrimSpace"), "(", prefix, ".", field.GoName, "[i])")
				g.P("}")

			} else {
				g.P(prefix, ".", field.GoName, " = ", stringsPackage.Ident("TrimSpace"), "(", prefix, ".", field.GoName, ")")
			}
		}

		if fieldValidator, _ := proto.GetExtension(desc.Options(), options.E_Field).(*options.FieldValidator); fieldValidator != nil {
			if fieldValidator.Require != nil && *fieldValidator.Require {
				generateRequire(structName, prefix, field, g)
			}

			if fieldValidator.Eq != nil && *fieldValidator.Eq != "" {
				generateEQNE(structName, prefix, field, "==", *fieldValidator.Eq, g)
			}

			if fieldValidator.Ne != nil && *fieldValidator.Ne != "" {
				generateEQNE(structName, prefix, field, "!=", *fieldValidator.Ne, g)
			}

			if fieldValidator.Lt != nil {
				generateLTLEGTGE(structName, prefix, field, "<", strconv.FormatUint(uint64(*fieldValidator.Lt), 10), g)
			}

			if fieldValidator.Le != nil {
				generateLTLEGTGE(structName, prefix, field, "<=", strconv.FormatUint(uint64(*fieldValidator.Le), 10), g)
			}

			if fieldValidator.Gt != nil {
				generateLTLEGTGE(structName, prefix, field, ">", strconv.FormatUint(uint64(*fieldValidator.Gt), 10), g)
			}

			if fieldValidator.Ge != nil {
				generateLTLEGTGE(structName, prefix, field, ">=", strconv.FormatUint(uint64(*fieldValidator.Ge), 10), g)
			}

			if fieldValidator.MinCap != nil {
				generateCAPMinMax(structName, prefix, field, ">=", strconv.FormatUint(uint64(*fieldValidator.MinCap), 10), g)
			}

			if fieldValidator.MaxCap != nil {
				generateCAPMinMax(structName, prefix, field, "<=", strconv.FormatUint(uint64(*fieldValidator.MaxCap), 10), g)
			}

			if fieldValidator.CstDatetime != nil && *fieldValidator.CstDatetime {
				generateCSTDatetime(structName, prefix, field, g)
			}

			if fieldValidator.CstMinute != nil && *fieldValidator.CstMinute {
				generateCSTMinute(structName, prefix, field, g)
			}

			if fieldValidator.CstDay != nil && *fieldValidator.CstDay {
				generateCSTDay(structName, prefix, field, g)
			}

			if fieldValidator.CnMobile != nil && *fieldValidator.CnMobile {
				generateCNMobile(structName, prefix, field, g)
			}

			if fieldValidator.Duration != nil && *fieldValidator.Duration {
				generateDuration(structName, prefix, field, g)
			}
		}
	}

	g.P()
	g.P("return nil")
	g.P("}")
	g.P()

	for _, field := range message.Fields {
		desc := field.Desc

		if fieldValidator, _ := proto.GetExtension(desc.Options(), options.E_Field).(*options.FieldValidator); fieldValidator != nil {
			if fieldValidator.CstDatetime != nil && *fieldValidator.CstDatetime {
				g.P()
				g.P("func (", prefix, "*", structName, ") Parse", field.GoName, "() time.Time {")
				g.P("ts, _ := ", timePackage.Ident("ParseInLocation"), `("2006-01-02 15:04:05",`, prefix, ".", field.GoName, ", time.Local)")
				g.P("return ts")
				g.P("}")
			}

			if fieldValidator.CstMinute != nil && *fieldValidator.CstMinute {
				g.P()
				g.P("func (", prefix, "*", structName, ") Parse", field.GoName, "() time.Time {")
				g.P("ts, _ := ", timePackage.Ident("ParseInLocation"), `("2006-01-02 15:04",`, prefix, ".", field.GoName, ", time.Local)")
				g.P("return ts")
				g.P("}")
			}

			if fieldValidator.CstDay != nil && *fieldValidator.CstDay {
				g.P()
				g.P("func (", prefix, "*", structName, ") Parse", field.GoName, "() time.Time {")
				g.P("ts, _ := ", timePackage.Ident("ParseInLocation"), `("2006-01-02",`, prefix, ".", field.GoName, ", time.Local)")
				g.P("return ts")
				g.P("}")
			}

			if fieldValidator.Duration != nil && *fieldValidator.Duration {
				g.P()
				g.P("func (", prefix, "*", structName, ") Parse", field.GoName, "() time.Duration {")
				g.P("ts, _ := ", timePackage.Ident("ParseDuration"), "(", prefix, ".", field.GoName, ")")
				g.P("return ts")
				g.P("}")
			}
		}
	}
}

const (
	stringsPackage = protogen.GoImportPath("strings")
	timePackage    = protogen.GoImportPath("time")
	errorsPackage  = protogen.GoImportPath("github.com/bluekaki/pkg/errors")
)

func generateRequire(structName, prefix string, field *protogen.Field, g *protogen.GeneratedFile) {
	desc := field.Desc
	switch desc.Kind() {
	case protoreflect.BoolKind:
		if desc.IsList() {
			g.P()
			g.P("if len(", prefix, ".", field.GoName, ") == 0 {")
			g.P("return ", errorsPackage.Ident("New"), `("`, desc.Name(), ` required")`)
			g.P("}")
		}

	case protoreflect.Int32Kind,
		protoreflect.Sint32Kind,
		protoreflect.Uint32Kind,
		protoreflect.Int64Kind,
		protoreflect.Sint64Kind,
		protoreflect.Uint64Kind,
		protoreflect.Sfixed32Kind,
		protoreflect.Fixed32Kind,
		protoreflect.FloatKind,
		protoreflect.Sfixed64Kind,
		protoreflect.Fixed64Kind,
		protoreflect.DoubleKind:
		if desc.IsList() {
			g.P()
			g.P("if len(", prefix, ".", field.GoName, ") == 0 {")
			g.P("return ", errorsPackage.Ident("New"), `("`, desc.Name(), ` required")`)
			g.P("}")
		}

	case protoreflect.StringKind:
		if desc.IsList() {
			g.P()
			g.P("if len(", prefix, ".", field.GoName, ") == 0 {")
			g.P("return ", errorsPackage.Ident("New"), `("`, desc.Name(), ` required")`)
			g.P("}")

			g.P("for _, val := range ", prefix, ".", field.GoName, "{")
			g.P(`if val == "" {`)
			g.P("return ", errorsPackage.Ident("New"), `("`, field.GoName, ` contains empty value")`)
			g.P("}")
			g.P("}")
			return
		}

		g.P()
		g.P("if ", prefix, ".", field.GoName, ` == "" {`)
		g.P("return ", errorsPackage.Ident("New"), `("`, desc.Name(), ` required")`)
		g.P("}")

	case protoreflect.BytesKind:
		if desc.IsList() {
			g.P()
			g.P("if len(", prefix, ".", field.GoName, ") == 0 {")
			g.P("return ", errorsPackage.Ident("New"), `("`, desc.Name(), ` required")`)
			g.P("}")

			g.P("for _, val := range ", prefix, ".", field.GoName, "{")
			g.P(`if len(val) == 0 {`)
			g.P("return ", errorsPackage.Ident("New"), `("`, field.GoName, ` contains empty value")`)
			g.P("}")
			g.P("}")
			return
		}

		g.P()
		g.P("if len(", prefix, ".", field.GoName, ") == 0 {")
		g.P("return ", errorsPackage.Ident("New"), `("`, desc.Name(), ` required")`)
		g.P("}")

	case protoreflect.MessageKind: // map<,> or message{}
		if desc.IsMap() { // map<,>
			g.P()
			g.P("if len(", prefix, ".", field.GoName, ") == 0 {")
			g.P("return ", errorsPackage.Ident("New"), `("`, desc.Name(), ` required")`)
			g.P("}")
			return
		}

		if desc.IsList() { // repeated message{}
			g.P()
			g.P("if len(", prefix, ".", field.GoName, ") == 0 {")
			g.P("return ", errorsPackage.Ident("New"), `("`, desc.Name(), ` required")`)
			g.P("}")

			g.P("for _, val := range ", prefix, ".", field.GoName, "{")
			g.P(`if val == nil {`)
			g.P("return ", errorsPackage.Ident("New"), `("`, field.GoName, ` contains empty value")`)
			g.P("}")

			g.P("if err := val.Validate(); err != nil {")
			g.P("return err")
			g.P("}")

			g.P("}")
			return
		}

		if desc.HasPresence() { // message{}
			g.P()
			g.P("if ", prefix, ".", field.GoName, " == nil {")
			g.P("return ", errorsPackage.Ident("New"), `("`, desc.Name(), ` required")`)
			g.P("}")

			g.P("if err := ", prefix, ".", field.GoName, ".Validate(); err != nil {")
			g.P("return err")
			g.P("}")
			return
		}

		fallthrough

	default:
		g.P("// unknow kind")
		g.P("// ", field.GoName, " ", desc.Kind().String(), " ", desc)
	}
}

func generateEQNE(structName, prefix string, field *protogen.Field, operation, condition string, g *protogen.GeneratedFile) {
	condition = strings.TrimSpace(condition)

	desc := field.Desc
	switch desc.Kind() {
	case protoreflect.BoolKind,
		protoreflect.Int32Kind,
		protoreflect.Sint32Kind,
		protoreflect.Uint32Kind,
		protoreflect.Int64Kind,
		protoreflect.Sint64Kind,
		protoreflect.Uint64Kind,
		protoreflect.Sfixed32Kind,
		protoreflect.Fixed32Kind,
		protoreflect.FloatKind,
		protoreflect.Sfixed64Kind,
		protoreflect.Fixed64Kind,
		protoreflect.DoubleKind:
		if desc.IsList() {
			g.P()
			g.P("for _, val := range ", prefix, ".", field.GoName, "{")
			g.P("if !(val", operation, condition, "){")
			g.P("return ", errorsPackage.Ident("New"), `("`, desc.Name(), ` contains illegal value")`)
			g.P("}")
			g.P("}")
			return
		}

		g.P()
		g.P("if !(", prefix, ".", field.GoName, operation, condition, "){")
		g.P("return ", errorsPackage.Ident("New"), `("`, desc.Name(), ` illegal")`)
		g.P("}")

	case protoreflect.StringKind:
		if desc.IsList() {
			g.P()
			g.P("for _, val := range ", prefix, ".", field.GoName, "{")
			g.P("if !(val", operation, `"`, condition, `"){`)
			g.P("return ", errorsPackage.Ident("New"), `("`, desc.Name(), ` contains illegal value")`)
			g.P("}")
			g.P("}")
			return
		}

		g.P()
		g.P("if !(", prefix, ".", field.GoName, operation, `"`, condition, `"){`)
		g.P("return ", errorsPackage.Ident("New"), `("`, desc.Name(), ` illegal")`)
		g.P("}")
	}
}

func generateLTLEGTGE(structName, prefix string, field *protogen.Field, operation, condition string, g *protogen.GeneratedFile) {
	condition = strings.TrimSpace(condition)

	desc := field.Desc
	switch desc.Kind() {
	case protoreflect.BoolKind,
		protoreflect.Int32Kind,
		protoreflect.Sint32Kind,
		protoreflect.Uint32Kind,
		protoreflect.Int64Kind,
		protoreflect.Sint64Kind,
		protoreflect.Uint64Kind,
		protoreflect.Sfixed32Kind,
		protoreflect.Fixed32Kind,
		protoreflect.FloatKind,
		protoreflect.Sfixed64Kind,
		protoreflect.Fixed64Kind,
		protoreflect.DoubleKind:
		if desc.IsList() {
			g.P()
			g.P("for _, val := range ", prefix, ".", field.GoName, "{")
			g.P("if !(val", operation, condition, "){")
			g.P("return ", errorsPackage.Ident("New"), `("`, desc.Name(), ` contains illegal value")`)
			g.P("}")
			g.P("}")
			return
		}

		g.P()
		g.P("if !(", prefix, ".", field.GoName, operation, condition, "){")
		g.P("return ", errorsPackage.Ident("New"), `("`, desc.Name(), ` illegal")`)
		g.P("}")

	case protoreflect.StringKind:
		if desc.IsList() {
			g.P()
			g.P("for _, val := range ", prefix, ".", field.GoName, "{")
			g.P("if !(len([]rune(val))", operation, condition, "){")
			g.P("return ", errorsPackage.Ident("New"), `("`, desc.Name(), ` contains illegal value")`)
			g.P("}")
			g.P("}")
			return
		}

		g.P()
		g.P("if !(len([]rune(", prefix, ".", field.GoName, "))", operation, condition, "){")
		g.P("return ", errorsPackage.Ident("New"), `("`, desc.Name(), ` illegal")`)
		g.P("}")
	}
}

func generateCAPMinMax(structName, prefix string, field *protogen.Field, operation, condition string, g *protogen.GeneratedFile) {
	condition = strings.TrimSpace(condition)

	desc := field.Desc
	if desc.IsList() || desc.IsMap() || desc.Kind() == protoreflect.BytesKind {
		g.P()
		g.P("if !(len(", prefix, ".", field.GoName, ")", operation, condition, "){")
		g.P("return ", errorsPackage.Ident("New"), `("`, desc.Name(), ` capacity illegal")`)
		g.P("}")
	}
}

func generateCSTDatetime(structName, prefix string, field *protogen.Field, g *protogen.GeneratedFile) {
	desc := field.Desc

	g.P()
	g.P("if ", prefix, ".", field.GoName, ` != "" {`)
	g.P("if _, err := ", timePackage.Ident("ParseInLocation"), `("2006-01-02 15:04:05",`, prefix, ".", field.GoName, ", time.Local); err != nil {")
	g.P("return ", errorsPackage.Ident("Wrap"), `(err, "`, desc.Name(), ` illegal")`)
	g.P("}")
	g.P("}")
}

func generateCSTMinute(structName, prefix string, field *protogen.Field, g *protogen.GeneratedFile) {
	desc := field.Desc

	g.P()
	g.P("if ", prefix, ".", field.GoName, ` != "" {`)
	g.P("if _, err := ", timePackage.Ident("ParseInLocation"), `("2006-01-02 15:04",`, prefix, ".", field.GoName, ", time.Local); err != nil {")
	g.P("return ", errorsPackage.Ident("Wrap"), `(err, "`, desc.Name(), ` illegal")`)
	g.P("}")
	g.P("}")
}

func generateCSTDay(structName, prefix string, field *protogen.Field, g *protogen.GeneratedFile) {
	desc := field.Desc

	g.P()
	g.P("if ", prefix, ".", field.GoName, ` != "" {`)
	g.P("if _, err := ", timePackage.Ident("ParseInLocation"), `("2006-01-02",`, prefix, ".", field.GoName, ", time.Local); err != nil {")
	g.P("return ", errorsPackage.Ident("Wrap"), `(err, "`, desc.Name(), ` illegal")`)
	g.P("}")
	g.P("}")
}

func generateCNMobile(structName, prefix string, field *protogen.Field, g *protogen.GeneratedFile) {
	desc := field.Desc

	g.P()
	g.P("if len(", prefix, ".", field.GoName, ") != 11 || ", prefix, ".", field.GoName, `[0:1] != "1" {`)
	g.P("return ", errorsPackage.Ident("New"), `("`, desc.Name(), ` illegal")`)
	g.P("}")

	g.P("for _, v := range ", prefix, ".", field.GoName, "[1:] {")
	g.P("if v < '0' || v > '9' {")
	g.P("return ", errorsPackage.Ident("New"), `("`, desc.Name(), ` illegal")`)
	g.P("}")
	g.P("}")
}

func generateDuration(structName, prefix string, field *protogen.Field, g *protogen.GeneratedFile) {
	desc := field.Desc

	g.P()
	g.P("if ", prefix, ".", field.GoName, ` != "" {`)
	g.P("if _, err := ", timePackage.Ident("ParseDuration"), "(", prefix, ".", field.GoName, "); err != nil {")
	g.P("return ", errorsPackage.Ident("Wrap"), `(err, "`, desc.Name(), ` illegal")`)
	g.P("}")
	g.P("}")
}
